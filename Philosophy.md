The Ultraviolet virtual machine is inspired by Smalltalk-80. The specific details of that VM are not copied because it was designed a long time ago on hardware with archaic limitations. Another source of inspiration is the E programming language and its notion of capabilities.

There are also several VM efforts that acted as cautionary tales to inspire this design with their employment of VM design anti-patterns. In particular, programming language VMs fall into the trap of "ontogeny recapitulates phylogeny" wherein they reproduce the historical evolution of VMs throughout their design lifetime. There is no need to do this when we have hindsight and modernity to allow us to create better things. Simplicity does not mean constraining yourself to history. An example of this is that toy VMs often choose a stack-based model, which is not used in modern processor design. In the virtual world, simplicity also does not mean constraining yourself to physical limitations. Hobby VMs often limit the number of registers, a limitation imposed on real CPUs which serves little purpose in virtual ones.

Overall in programming language design there is much copying of the accidental properties of past and current systems rather than redesigning things to get back to the essential nature of things, which is at its heart quite simple. Even when simplicity is desired, there is a false economy found in a minimalism which is not based on matching the solution to the problem. An example of this is single instruction computers. Reducing the number of instructions is a good start at minimalism as modern CPUs have so many instructions that it is difficult for anyone to understand them all. However, the goal is not to get that number down to zero, it is to have a set of instructions which meet your needs. The right level of abstraction it one in which you are confronting the problem head on. If you have to first build your tools before you can do any work, then perhaps your system is too minimal. However, if you have to work around the tools in order to get anything done, then perhaps your system is not minimal enough. Ideally, you pick up the tools and get straight to work. The system disappears into the work itself, invisible. This is the ideal. The Ultraviolet VM attempts to blur the traditional distinction between machine, operating system, library, and programming language. It is a set of tools that can be combined to do productive work. It is meant to be extended in the direction necessary to do the sort of work you have in mind, while leaving out anything unnecessary.

Another key philosophical goal is portability. One of the reasons C is indispensible is because it provides just enough abstraction so that you don't have to rewrite all of your code for every processor (although you do have to rewrite some code!) and this is very valuable. However, we can become stuck with C because no one wants to write all of the necessary compilers to get another language to run on all of those processors. Fortunately, there is no need to do this, nor even to compile everything to C. Although C is ubiquitous, it is not present at every layer of abstraction. It provides a base layer, but a lot of the action that you want to get involved with is at a higher layer, in an increasingly fragmented ecosystem of platform-favored languages. Depending on the machine you are using, there is likely a favored language that has better access to the operating system services than C, unless you are on Linux, which has historically been very C-centric. The right target for compilation is therefore these high-level languages with preferred status and greater access. However, there is no one best target, every platform has its own preferences. Therefore, what we need at this time in the evolution of computing is not a new C at all, but a new language that has the same value as C used to but in this new context. We need a language that compiles into all platform-favored languages in order to provide a neutral cross-platform target. Then this can become the new basis on which we built things, just like C was in the times of old. This is the goal of the Ultraviolet VM, to be a compilation target that you can rely on to run on all of your computers. As these compilation targets are not assembly, we can disregard all of the hard work of making something compile into assembly. In particular, we do not need to provide low-level memory management operations whatsoever. C, the most basic compilation target that merits consideration in the modern era, already provides malloc/free. So this is the worst case scenario, and many languages do significantly better, offering some form of automatic memory management. Much of the work of old VMs was handling memory and this work can all be removed from the necessary work of VM creation now. Additionally, we have no need to mimic assembly and limit the available operations to integer and floating point math. All target languages give us these operations in the base language. However, we need not stop there as through libraries most languages can provide at least basic data structures.

One of the anti-patterns that I sought to avoid in the Ultraviolet virtual machine was optimization to make the VM bytecode small. Generally, memory is plentiful these days and adding complexity to reduce memory footprint is a false economy. Examples of this anti-pattern are prevalent on real CPUs, but can also be seen in the Smalltalk-80 VM (which did actually have extreme hardware memory constraints at the time, unlike now) in the use of boxed and unboxed integers. Often these are added to a language for performance, but in Smalltalk it was a way to compress integers since integers are used extensively in object records, for instance as lengths. Similarly, Smalltalk-80 adds complexity in the name of bytecode compression by technically having 256 bytecodes. Semantically, there are fewer than 256 operations. However, in order to compress the bytecodes some of them include an operand combined with the operator in a single byte by using operators less than 8 bits in size. Having 256 apparent bytecodes makes the system seem more complex than it really is. This tendency can also be seen, for instance, in RISC-V's compressed instruction set extension. There are good reasons to due this on a CPU, where fitting instructions into the cache is essential for increased performance, but in a VM these performance gains are lost. Overall, I think there is perhaps more performance benefit in using machine word sizes for most things rather than trying for memory reduction as there is a lot of effort wasted in converting between the VM word size and the physical CPU word size. This is why I have attempted to make the Ultraviolet VM word size independent so that it can work on the word size of the hardware without translation. This does mean that you will get different results when you run some programs on different hardware, which it turns out is always the case anyway. A VM is an idealized machine, but programs written for the VM always run on actual machines, which have a variety of quirks and limitations. Abstraction can never save you from the underlying physical reality, so abstractions that pretend to do so are dangerous and distracting.

Two VMs with great ideas that radically simplify programming are Python and Lua. Python uses a single number type for integers, the big integer. This has the beautiful side effect of making python integers machine word size independent! Lua beautifully simplifies even further, with a single number type that combines integers and floating point numbers. Similarly, it combines dictionaries and arrays. While this may seem like a huge performance disadvantage, in practice the most common uses where performance optimization is possible can be added as special cases to the VM interpreter. There is no need to force the programmer into using only the most performant options by depriving them of choice. There is also generally no need to force the programmer to choose which specific implementation they want to use in order to optimize performance when the VM is the keeper of all of the profiling information necessary to make such a decision. When possible, I prefer reasonable defaults with special case performance optimization to happen all inside the VM, allowing the programmer to focus on high-level semantics and not low-level implementation logic.

Garbage collection has been quite a quandry for me for a long time. This is because it is simultaneously a source of simplicity and complexity. Moving from manual memory allocation to garbage collection is one of the biggest leaps in programming language productivity ever made. However, garbage collection algorithms are also one of the biggest sources of VM implementation complexity. 